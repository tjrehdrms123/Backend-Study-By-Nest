# SOLID 원칙 객체지향

### SOLID의 원칙이란?
> SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 스멜을 제거하기 위해 적용할 수 있는 지침이다.

## `S	SRP	`
단일 책임 원칙 (Single responsibility principle)
한 클래스는 하나의 책임만 가져야 합니다 모든 모듈이 단 하나의 일만 해야 한다는 의미가 아닙니다.
이 말의 진짜 의미는 `하나의 클래스`는 `하나의 액터`만을 담당해야한다는 의미입니다.
변경해야되는 구조는 액터가 변경한 요구사항 다른 곳에도 영향을 줄 가능성이 있는 구조입니다.

> `액터`란 클래스를 변화시킬 수 있는 주체를 의미합니다

### SRP 적용 전 예제
```js
class 매장{
  목록(){
    ...
  }
  주문받기(){
    ...
  }
  요리하기(){
    ...
  }
  계산하기(){
    ...
  }
}
```
> 매장을 담당하는 매장 클래스는 4가지의 메소드가 있습니다
- 목록 : 할수있는 요리와 가격이 있습니다 -> 대표님이 사용합니다.
- 주문받기 : 주문을 받습니다 -> 주문팀에서 사용합니다.
- 요리하기 : 요리를 시작합니다 -> 요리사팀에서 사용합니다.
- 계산하기 : 계산서를 확인 후 계산합니다. -> 계산팀에서 사용합니다.

> 예시의 상황입니다. 대표님께서 물가상승률을 반영해 요리의 가격을 모두 10% 상승시켰습니다. 그때 변경해야되는 메소드는 `목록` 메소드 입니다. 그에 따라 계산하는 계산서에도 반영이 되어야됩니다. 서로 다른 액터끼리 의존적일때 `SRP`에 위배된다고 합니다.
> 클래스를 변화시킬 수 있는 주체는 액터는 `대표님`, `주문팀`, `요리사팀`, `계산서팀`이 있습니다.

### 액터를 나눌수있는 방법
> 위처럼 여러의 액터가 있을때 어떻게 해결 할 수 있을까요?
> 변경된 코드는 매장 클래스의 인스턴스를 생성하고 각 클래스의 메서드를 사용하는 역할만 합니다.
 - `Layer`를 쌓아서 구현부를 추상화 한다.(Facade Patter 퍼사드 패턴)
```js
class 매장{
  목록(){
    new 대표님().목록();
  }
}
...

class 대표님{
    목록(){
    ...
  }
}
...
```

### SRP 적용 후 이점
> 책임 영역이 확실해지기 때문에 한 책임의 변경으로 다른 책임의 변경으로의 연쇄직용에서 자유로울수 있습니다.
> 필자는 진행하는 프로젝트에서 여러가지 예약 프로그램을 하나의 예약 프로그램으로 통합을한 겅험이 있습니다. 그떄 에러 연쇄작용이 일어나 구멍 막기를 하면서 필요성을 느꼈습니다.
```markdown
A클래스의 기능을 수정할때 책임 영역이 불확실해 다른 클래스의 기능까지 수정해줘야되는 연쇄작용의 예시
A수정 -> B수정 -> C수정 -> A수정
```

### 참고
- https://youtu.be/5UGjfLFEP9s